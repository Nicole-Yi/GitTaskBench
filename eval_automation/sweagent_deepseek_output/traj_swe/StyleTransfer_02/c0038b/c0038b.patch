diff --git a/check_pil.py b/check_pil.py
new file mode 100644
index 00000000..01cc4ef5
--- /dev/null
+++ b/check_pil.py
@@ -0,0 +1,6 @@
+
+try:
+    from PIL import Image
+    print("PIL is available.")
+except ImportError:
+    print("PIL is not available.")
\ No newline at end of file
diff --git a/run_reconstruction.py b/run_reconstruction.py
new file mode 100644
index 00000000..3bb97b5b
--- /dev/null
+++ b/run_reconstruction.py
@@ -0,0 +1,26 @@
+
+import os
+from reconstruct_image_from_representation import reconstruct_image_from_representation
+
+# Configuration for reconstruction
+config = {
+    'should_reconstruct_content': True,
+    'should_visualize_representation': False,
+    'content_img_name': 'StyleTransfer_02_input.jpg',
+    'content_images_dir': '/data/data/agent_test_codebase/GitTaskBench/queries/StyleTransfer_02/input',
+    'style_img_name': 'dummy.jpg',  # Not used for content reconstruction
+    'style_images_dir': '/data/data/agent_test_codebase/GitTaskBench/code_base/StyleTransfer/data/style-images',
+    'output_img_dir': '/data/data/agent_test_codebase/GitTaskBench/eval_automation/output/StyleTransfer_02',
+    'model': 'vgg19',
+    'height': 500,
+    'optimizer': 'lbfgs',
+    'img_format': (4, '.png'),
+}
+
+# Ensure output directory exists
+os.makedirs(config['output_img_dir'], exist_ok=True)
+
+# Run reconstruction
+reconstruct_image_from_representation(config)
+
+print("Reconstruction completed successfully.")
\ No newline at end of file
diff --git a/utils_minimal.py b/utils_minimal.py
new file mode 100644
index 00000000..3f80840e
--- /dev/null
+++ b/utils_minimal.py
@@ -0,0 +1,76 @@
+
+import numpy as np
+import torch
+from torchvision import transforms
+import os
+import matplotlib.pyplot as plt
+
+IMAGENET_MEAN_255 = [123.675, 116.28, 103.53]
+IMAGENET_STD_NEUTRAL = [1, 1, 1]
+
+def load_image(img_path, target_shape=None):
+    if not os.path.exists(img_path):
+        raise Exception(f'Path does not exist: {img_path}')
+    img = plt.imread(img_path)
+    
+    if target_shape is not None:
+        if isinstance(target_shape, int) and target_shape != -1:
+            current_height, current_width = img.shape[:2]
+            new_height = target_shape
+            new_width = int(current_width * (new_height / current_height))
+            img = plt.imresize(img, (new_width, new_height))
+        else:
+            img = plt.imresize(img, (target_shape[1], target_shape[0]))
+    
+    img = img.astype(np.float32)
+    img /= 255.0
+    return img
+
+def save_image(img, img_path):
+    if len(img.shape) == 2:
+        img = np.stack((img,) * 3, axis=-1)
+    plt.imsave(img_path, img)
+
+def prepare_img(img_path, target_shape, device):
+    img = load_image(img_path, target_shape=target_shape)
+    transform = transforms.Compose([
+        transforms.ToTensor(),
+        transforms.Lambda(lambda x: x.mul(255)),
+        transforms.Normalize(mean=IMAGENET_MEAN_255, std=IMAGENET_STD_NEUTRAL)
+    ])
+    img = transform(img).to(device).unsqueeze(0)
+    return img
+
+def generate_out_img_name(config):
+    prefix = os.path.basename(config['content_img_name']).split('.')[0] + '_' + os.path.basename(config['style_img_name']).split('.')[0]
+    if 'reconstruct_script' in config:
+        suffix = f'_o_{config["optimizer"]}_h_{str(config["height"])}_m_{config["model"]}{config["img_format"][1]}'
+    else:
+        suffix = f'_o_{config["optimizer"]}_i_{config["init_method"]}_h_{str(config["height"])}_m_{config["model"]}_cw_{config["content_weight"]}_sw_{config["style_weight"]}_tv_{config["tv_weight"]}{config["img_format"][1]}'
+    return prefix + suffix
+
+def save_and_maybe_display(optimizing_img, dump_path, config, img_id, num_of_iterations, should_display=False):
+    saving_freq = config['saving_freq']
+    out_img = optimizing_img.squeeze(axis=0).to('cpu').detach().numpy()
+    out_img = np.moveaxis(out_img, 0, 2)
+    
+    if img_id == num_of_iterations-1 or (saving_freq > 0 and img_id % saving_freq == 0):
+        img_format = config['img_format']
+        out_img_name = str(img_id).zfill(img_format[0]) + img_format[1] if saving_freq != -1 else generate_out_img_name(config)
+        dump_img = np.copy(out_img)
+        dump_img += np.array(IMAGENET_MEAN_255).reshape((1, 1, 3))
+        dump_img = np.clip(dump_img, 0, 255).astype('uint8')
+        save_image(dump_img, os.path.join(dump_path, out_img_name))
+    
+    if should_display:
+        plt.imshow(np.uint8(get_uint8_range(out_img)))
+        plt.show()
+
+def get_uint8_range(x):
+    if isinstance(x, np.ndarray):
+        x -= np.min(x)
+        x /= np.max(x)
+        x *= 255
+        return x
+    else:
+        raise ValueError(f'Expected numpy array got {type(x)}')
\ No newline at end of file
