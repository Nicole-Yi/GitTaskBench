{"model_name_or_path": "default__claude-3-5-sonnet-20241022__t-0.00__p-1.00__c-3.00___991330", "instance_id": "991330", "model_patch": "diff --git a/parse_excel.py b/parse_excel.py\nnew file mode 100644\nindex 00000000..9d978adc\n--- /dev/null\n+++ b/parse_excel.py\n@@ -0,0 +1,125 @@\n+\n+import os\n+import sys\n+import json\n+from pathlib import Path\n+import zipfile\n+import xml.etree.ElementTree as ET\n+from datetime import datetime, timedelta\n+\n+# Input and output paths\n+input_file = '/data/data/agent_test_codebase/GitTaskBench/queries/Eparse_02/input/Eparse_02_input.xlsx'\n+output_dir = '/data/data/agent_test_codebase/GitTaskBench/eval_automation/output/Eparse_02'\n+output_file = os.path.join(output_dir, 'output.txt')\n+\n+# Create output directory if it doesn't exist\n+os.makedirs(output_dir, exist_ok=True)\n+\n+def excel_date_to_str(excel_date):\n+    \"\"\"Convert Excel date number to string date.\"\"\"\n+    try:\n+        # Excel's date system starts from December 30, 1899\n+        excel_epoch = datetime(1899, 12, 30)\n+        # Convert Excel date (which is a number of days since epoch) to datetime\n+        dt = excel_epoch + timedelta(days=float(excel_date))\n+        return dt.strftime('%Y-%m-%d')\n+    except (ValueError, TypeError):\n+        return excel_date  # Return original value if conversion fails\n+\n+def read_xlsx_content(xlsx_path):\n+    \"\"\"Read Excel file content directly from the XML structure\"\"\"\n+    result = {}\n+    \n+    try:\n+        # Open Excel file as a zip file\n+        with zipfile.ZipFile(xlsx_path) as zf:\n+            # Read shared strings if available\n+            shared_strings = []\n+            if 'xl/sharedStrings.xml' in zf.namelist():\n+                with zf.open('xl/sharedStrings.xml') as f:\n+                    xml = ET.parse(f)\n+                    for si in xml.findall('.//{*}si'):\n+                        t = si.find('.//{*}t')\n+                        if t is not None:\n+                            shared_strings.append(t.text or '')\n+            \n+            # Read sheets data\n+            with zf.open('xl/workbook.xml') as f:\n+                wb = ET.parse(f)\n+                sheets = wb.findall('.//{*}sheet')\n+                \n+                for sheet in sheets:\n+                    sheet_name = sheet.get('name')\n+                    sheet_id = sheet.get('sheetId')\n+                    sheet_data = []\n+                    \n+                    # Read sheet content\n+                    with zf.open(f'xl/worksheets/sheet{sheet_id}.xml') as sf:\n+                        sheet_xml = ET.parse(sf)\n+                        rows = sheet_xml.findall('.//{*}row')\n+                        \n+                        if rows:\n+                            # Get headers from first row\n+                            header_cells = rows[0].findall('.//{*}c')\n+                            headers = []\n+                            for cell in header_cells:\n+                                v = cell.find('.//{*}v')\n+                                if v is not None:\n+                                    value = v.text or ''\n+                                    # If it's a shared string\n+                                    if cell.get('t') == 's':\n+                                        value = shared_strings[int(value)]\n+                                    headers.append(value)\n+                            \n+                            # Process data rows\n+                            for row in rows[1:]:\n+                                cells = row.findall('.//{*}c')\n+                                row_data = {}\n+                                for i, cell in enumerate(cells):\n+                                    if i < len(headers):\n+                                        v = cell.find('.//{*}v')\n+                                        if v is not None:\n+                                            value = v.text or ''\n+                                            # If it's a shared string\n+                                            if cell.get('t') == 's':\n+                                                value = shared_strings[int(value)]\n+                                            # Convert dates if the header is '\u65e5\u671f'\n+                                            if headers[i] == '\u65e5\u671f':\n+                                                value = excel_date_to_str(value)\n+                                            row_data[headers[i]] = value\n+                                        else:\n+                                            row_data[headers[i]] = ''\n+                                if row_data:\n+                                    sheet_data.append(row_data)\n+                    \n+                    result[sheet_name] = sheet_data\n+    except Exception as e:\n+        print(f\"Error reading Excel file: {e}\")\n+        return None\n+    \n+    return result\n+\n+try:\n+    # Read Excel file content\n+    excel_data = read_xlsx_content(input_file)\n+    \n+    if excel_data:\n+        # Write to output file\n+        with open(output_file, 'w', encoding='utf-8') as f:\n+            for sheet_name, rows in excel_data.items():\n+                f.write(f\"Sheet: {sheet_name}\\n\")\n+                f.write(\"-\" * 50 + \"\\n\")\n+                \n+                for row in rows:\n+                    f.write(json.dumps(row, ensure_ascii=False) + \"\\n\")\n+                \n+                f.write(\"\\n\")  # Add blank line between sheets\n+        \n+        print(f\"Excel file has been parsed and saved to {output_file}\")\n+    else:\n+        print(\"Failed to read Excel file\")\n+        sys.exit(1)\n+\n+except Exception as e:\n+    print(f\"Error processing file: {e}\")\n+    sys.exit(1)\n\\ No newline at end of file\n"}